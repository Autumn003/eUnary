{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "reveal-pane",
  "type": "registry:ui",
  "title": "Reveal Pane",
  "author": "Hemant Sharma <hemant.develop@gmail.com>",
  "description": "Image comparison slider drag to reveal differences between two images",
  "dependencies": [
    "class-variance-authority",
    "motion",
    "clsx",
    "tailwind-merge",
    "@tabler/icons-react",
    "@tsparticles/react",
    "@tsparticles/engine",
    "@tsparticles/slim"
  ],
  "files": [
    {
      "path": "../docs/components/ui/reveal-pane.tsx",
      "content": "'use client';\n\nimport { useEffect, useRef, useState } from 'react';\nimport { motion, useAnimation } from 'motion/react';\nimport Image from 'next/image';\nimport { IconGripVertical } from '@tabler/icons-react';\nimport Particles, { initParticlesEngine } from '@tsparticles/react';\nimport { type Container, type ISourceOptions } from '@tsparticles/engine';\nimport { loadSlim } from '@tsparticles/slim';\nimport { cn } from '@/lib/utils';\n\ninterface RevealSliderProps {\n    className?: string;\n    leftImgClassName?: string;\n    rightImgClassName?: string;\n    leftImgSrc?: string;\n    rightImgSrc?: string;\n    slideDirection?: 'left' | 'right';\n    autoplay?: boolean;\n    duration?: number;\n    pauseOnHover?: boolean;\n    loop?: boolean;\n}\n\nexport const RevealPane = ({\n    className,\n    leftImgClassName,\n    rightImgClassName,\n    leftImgSrc = '',\n    rightImgSrc = '',\n    slideDirection = 'right',\n    autoplay = false,\n    duration = 5000,\n    pauseOnHover = true,\n    loop = true,\n}: RevealSliderProps) => {\n    const [sliderPosition, setSliderPosition] = useState(50);\n    const [isDragging, setIsDragging] = useState(false);\n    const [isHovered, setIsHovered] = useState(false);\n    const [direction, setDirection] = useState<'left' | 'right' | null>(null);\n    const [isAutoPlaying, setIsAutoPlaying] = useState(autoplay);\n    const [autoplayDirection, setAutoplayDirection] = useState<\n        'left' | 'right'\n    >('right');\n\n    const prevPositionRef = useRef(sliderPosition);\n    const autoplayIntervalRef = useRef<NodeJS.Timeout | null>(null);\n    const autoplayTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n    useEffect(() => {\n        if (sliderPosition > prevPositionRef.current && isDragging) {\n            setDirection('right');\n        } else if (sliderPosition < prevPositionRef.current && isDragging) {\n            setDirection('left');\n        } else if (!isDragging) {\n            setDirection(null);\n        }\n        prevPositionRef.current = sliderPosition;\n    }, [sliderPosition, isDragging]);\n\n    // Autoplay logic\n    useEffect(() => {\n        if (!autoplay || isDragging || (pauseOnHover && isHovered)) {\n            if (autoplayIntervalRef.current) {\n                clearInterval(autoplayIntervalRef.current);\n                autoplayIntervalRef.current = null;\n            }\n            if (autoplayTimeoutRef.current) {\n                clearTimeout(autoplayTimeoutRef.current);\n                autoplayTimeoutRef.current = null;\n            }\n            return;\n        }\n\n        if (isAutoPlaying) {\n            const startAutoplay = () => {\n                autoplayIntervalRef.current = setInterval(() => {\n                    setSliderPosition((prev) => {\n                        let newPosition;\n\n                        if (autoplayDirection === 'right') {\n                            newPosition = Math.min(prev + 1, 100);\n                            if (newPosition === 100 && loop) {\n                                // Switch direction after a pause\n                                autoplayTimeoutRef.current = setTimeout(() => {\n                                    setAutoplayDirection('left');\n                                }, 1000);\n                            }\n                        } else {\n                            newPosition = Math.max(prev - 1, 0);\n                            if (newPosition === 0 && loop) {\n                                // Switch direction after a pause\n                                autoplayTimeoutRef.current = setTimeout(() => {\n                                    setAutoplayDirection('right');\n                                }, 1000);\n                            }\n                        }\n\n                        return newPosition;\n                    });\n                }, duration * 10); // multiply duration by 10 for smooth animation\n            };\n\n            startAutoplay();\n        }\n\n        return () => {\n            if (autoplayIntervalRef.current) {\n                clearInterval(autoplayIntervalRef.current);\n            }\n            if (autoplayTimeoutRef.current) {\n                clearTimeout(autoplayTimeoutRef.current);\n            }\n        };\n    }, [\n        autoplay,\n        isAutoPlaying,\n        isDragging,\n        isHovered,\n        pauseOnHover,\n        duration,\n        autoplayDirection,\n        loop,\n    ]);\n\n    // Initialize autoplay direction based on slideDirection prop\n    useEffect(() => {\n        setAutoplayDirection(slideDirection);\n    }, [slideDirection]);\n\n    // Helper function to get position from event (mouse or touch)\n    const getEventPosition = (e: any) => {\n        const clientX = e.touches ? e.touches[0].clientX : e.clientX;\n        const clientY = e.touches ? e.touches[0].clientY : e.clientY;\n        return { clientX, clientY };\n    };\n\n    // Helper function to update slider position\n    const updateSliderPosition = (clientX: number, rect: DOMRect) => {\n        const x = clientX - rect.left;\n        const percentage = (x / rect.width) * 100;\n        setSliderPosition(Math.min(Math.max(percentage, 0), 100));\n    };\n\n    const handleMove = (e: any) => {\n        if (!isDragging) return;\n\n        const { clientX } = getEventPosition(e);\n        const rect = e.currentTarget.getBoundingClientRect();\n        updateSliderPosition(clientX, rect);\n    };\n\n    const handleStart = () => {\n        setIsDragging(true);\n        setIsAutoPlaying(false); // Pause autoplay when user interacts\n    };\n\n    const handleEnd = () => {\n        setIsDragging(false);\n        // Resume autoplay after user interaction if it was initially enabled\n        if (autoplay) {\n            setTimeout(() => setIsAutoPlaying(true), 1000); // Resume after 1 second\n        }\n    };\n\n    const handleClick = (e: any) => {\n        // Prevent click handling if it was a drag operation\n        if (isDragging) return;\n\n        const { clientX } = getEventPosition(e);\n        const rect = e.currentTarget.getBoundingClientRect();\n        updateSliderPosition(clientX, rect);\n\n        // Pause and resume autoplay on click\n        if (autoplay) {\n            setIsAutoPlaying(false);\n            setTimeout(() => setIsAutoPlaying(true), 1000);\n        }\n    };\n\n    const handleMouseEnter = () => {\n        setIsHovered(true);\n    };\n\n    const handleMouseLeave = () => {\n        setIsHovered(false);\n    };\n\n    useEffect(() => {\n        const handleGlobalEnd = () => setIsDragging(false);\n\n        const handleGlobalMove = (e: any) => {\n            if (!isDragging) return;\n\n            const { clientX, clientY } = getEventPosition(e);\n            const containers = document.querySelectorAll(\n                '[data-slider-container]'\n            );\n\n            containers.forEach((container) => {\n                const rect = container.getBoundingClientRect();\n                if (\n                    clientX >= rect.left &&\n                    clientX <= rect.right &&\n                    clientY >= rect.top &&\n                    clientY <= rect.bottom\n                ) {\n                    updateSliderPosition(clientX, rect);\n                }\n            });\n        };\n\n        // Add both mouse and touch event listeners\n        document.addEventListener('mouseup', handleGlobalEnd);\n        document.addEventListener('mousemove', handleGlobalMove);\n        document.addEventListener('touchend', handleGlobalEnd);\n        document.addEventListener('touchmove', handleGlobalMove, {\n            passive: false,\n        });\n\n        return () => {\n            document.removeEventListener('mouseup', handleGlobalEnd);\n            document.removeEventListener('mousemove', handleGlobalMove);\n            document.removeEventListener('touchend', handleGlobalEnd);\n            document.removeEventListener('touchmove', handleGlobalMove);\n        };\n    }, [isDragging]);\n\n    return (\n        <div\n            className={cn(\n                'relative aspect-auto min-h-72 min-w-84 cursor-pointer touch-none overflow-hidden rounded-lg bg-gray-800 select-none sm:aspect-[4/3] sm:min-h-96 sm:min-w-96',\n                className\n            )}\n            data-slider-container\n            // Mouse events\n            onMouseMove={handleMove}\n            onMouseDown={handleStart}\n            onMouseUp={handleEnd}\n            onClick={handleClick}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n            // Touch events\n            onTouchStart={handleStart}\n            onTouchMove={handleMove}\n            onTouchEnd={handleEnd}\n        >\n            {/* right image */}\n            <div className={cn('absolute inset-0', rightImgClassName)}>\n                <Image\n                    src={rightImgSrc}\n                    alt=\"right image\"\n                    width={800}\n                    height={800}\n                    className=\"h-full w-full object-cover\"\n                    draggable={false}\n                />\n            </div>\n\n            {/* left image*/}\n            <motion.div\n                className={cn('absolute inset-0', leftImgClassName)}\n                style={{\n                    clipPath: `inset(0 ${100 - sliderPosition}% 0 0)`,\n                }}\n                animate={{\n                    clipPath: `inset(0 ${100 - sliderPosition}% 0 0)`,\n                }}\n                transition={{\n                    type: 'tween',\n                    duration: isDragging ? 0 : isAutoPlaying ? 0.1 : 0.3,\n                    ease: 'easeOut',\n                }}\n            >\n                <Image\n                    src={leftImgSrc}\n                    alt=\"Cute animals in color\"\n                    className=\"h-full w-full object-cover\"\n                    width={800}\n                    height={800}\n                    draggable={false}\n                />\n            </motion.div>\n\n            {/* Slider Line */}\n            <motion.div\n                className=\"absolute top-0 bottom-0 z-10 w-0.5 bg-gradient-to-b from-transparent via-purple-400 to-transparent shadow-lg\"\n                style={{ left: `${sliderPosition}%` }}\n                animate={{ left: `${sliderPosition}%` }}\n                transition={{\n                    type: 'tween',\n                    duration: isDragging ? 0 : isAutoPlaying ? 0.1 : 0.3,\n                    ease: 'easeOut',\n                }}\n            >\n                {/* Slider Handle */}\n                <div className=\"absolute top-1/2 left-1/2 z-20 -translate-x-1/2 -translate-y-1/2 transform\">\n                    <motion.div\n                        className=\"z-20 flex h-8 w-8 cursor-grab items-center justify-center rounded-full border-1 border-purple-400 bg-purple-500 shadow-lg active:cursor-grabbing\"\n                        whileHover={{ scale: 1.1 }}\n                        whileTap={{ scale: 0.95 }}\n                        animate={{\n                            scale: isDragging\n                                ? 1.1\n                                : isAutoPlaying && !isHovered\n                                  ? [1, 1.1, 1]\n                                  : 1,\n                            boxShadow: isDragging\n                                ? '0 0 50px rgba(173,70,255)'\n                                : isAutoPlaying && !isHovered\n                                  ? '0 0 25px rgba(173,70,255,0.8)'\n                                  : '0 0 15px rgba(173,70,255,0.5)',\n                        }}\n                        transition={{\n                            duration: 2,\n                            repeat: isAutoPlaying && !isHovered ? Infinity : 0,\n                            ease: 'easeInOut',\n                        }}\n                    >\n                        <IconGripVertical className=\"h-4 w-4 text-white\" />\n                    </motion.div>\n                </div>\n\n                {/* Direction indicator sparkles */}\n                <div\n                    className={cn(\n                        'absolute top-1/2 left-1/2 h-full w-20 -translate-y-1/2 transform bg-purple-300/10',\n                        (direction === 'left' ||\n                            (isAutoPlaying && autoplayDirection === 'left')) &&\n                            'translate-x-0 [mask-image:radial-gradient(400px_1000px_at_left,white,transparent_20%)]',\n                        (direction === 'right' ||\n                            (isAutoPlaying && autoplayDirection === 'right')) &&\n                            '-translate-x-full [mask-image:radial-gradient(400px_1000px_at_right,white,transparent_20%)]',\n                        !direction && !isAutoPlaying && 'hidden'\n                    )}\n                >\n                    <Sparkles\n                        background=\"transparent\"\n                        minSize={0.4}\n                        maxSize={1}\n                        particleDensity={100}\n                        particleColor=\"#ffffff\"\n                        speed={isAutoPlaying ? 0.5 : 1}\n                    />\n                </div>\n            </motion.div>\n        </div>\n    );\n};\n\ntype ParticlesProps = {\n    className?: string;\n    background?: string;\n    particleSize?: number;\n    minSize?: number;\n    maxSize?: number;\n    speed?: number;\n    particleColor?: string;\n    particleDensity?: number;\n};\n\nexport const Sparkles = ({\n    background,\n    minSize,\n    maxSize,\n    speed,\n    particleColor,\n    particleDensity,\n}: ParticlesProps) => {\n    const [init, setInit] = useState(false);\n\n    useEffect(() => {\n        initParticlesEngine(async (engine) => {\n            await loadSlim(engine);\n        }).then(() => {\n            setInit(true);\n        });\n    }, []);\n\n    const fadeInControls = useAnimation();\n\n    const particlesLoaded = async (container?: Container): Promise<void> => {\n        container &&\n            fadeInControls.start({\n                opacity: 1,\n                transition: { duration: 1 },\n            });\n    };\n\n    const options: ISourceOptions = {\n        background: {\n            color: {\n                value: background || '#0d47a1',\n            },\n        },\n        fullScreen: {\n            enable: false,\n            zIndex: 1,\n        },\n\n        particles: {\n            color: {\n                value: particleColor || '#ffffff',\n            },\n            move: {\n                angle: {\n                    offset: 0,\n                    value: 90,\n                },\n                center: {\n                    x: 50,\n                    y: 50,\n                    mode: 'percent',\n                    radius: 0,\n                },\n                enable: true,\n                random: false,\n                size: false,\n                speed: {\n                    min: 0.1,\n                    max: 1,\n                },\n            },\n            number: {\n                density: {\n                    enable: true,\n                    width: 400,\n                    height: 400,\n                },\n                limit: {\n                    mode: 'delete',\n                    value: 0,\n                },\n                value: particleDensity || 120,\n            },\n            opacity: {\n                value: {\n                    min: 0.1,\n                    max: 1,\n                },\n                animation: {\n                    enable: true,\n                    speed: speed || 4,\n                    sync: false,\n                    mode: 'auto',\n                    startValue: 'random',\n                    destroy: 'none',\n                },\n            },\n            shape: {\n                close: true,\n                fill: true,\n                options: {},\n                type: 'circle',\n            },\n            size: {\n                value: {\n                    min: minSize || 1,\n                    max: maxSize || 3,\n                },\n            },\n        },\n    };\n\n    if (init) {\n        return (\n            <motion.div\n                animate={fadeInControls}\n                className={cn('h-full w-full opacity-0')}\n            >\n                <Particles\n                    className=\"h-full w-full\"\n                    id=\"tsparticles\"\n                    particlesLoaded={particlesLoaded}\n                    options={options}\n                />\n            </motion.div>\n        );\n    }\n\n    return <></>;\n};\n",
      "type": "registry:ui",
      "target": "components/ui/reveale-pane.tsx"
    }
  ]
}