{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "reveal-pane",
  "type": "registry:ui",
  "title": "Reveal Pane",
  "author": "Hemant Sharma <hemant.develop@gmail.com>",
  "description": "Image comparison slider drag to reveal differences between two images",
  "dependencies": [
    "class-variance-authority",
    "motion",
    "clsx",
    "tailwind-merge",
    "@tabler/icons-react",
    "@tsparticles/react",
    "@tsparticles/engine",
    "@tsparticles/slim"
  ],
  "files": [
    {
      "path": "../docs/components/ui/reveal-pane.tsx",
      "content": "'use client';\r\n\r\nimport React, { useEffect, useId, useRef, useState } from 'react';\r\nimport { motion, useAnimation } from 'motion/react';\r\nimport Image from 'next/image';\r\nimport { IconGripVertical } from '@tabler/icons-react';\r\nimport Particles, { initParticlesEngine } from '@tsparticles/react';\r\nimport { type Container, type ISourceOptions } from '@tsparticles/engine';\r\nimport { loadSlim } from '@tsparticles/slim';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface RevealSliderProps {\r\n    className?: string;\r\n    leftImgClassName?: string;\r\n    rightImgClassName?: string;\r\n    leftImgSrc?: string;\r\n    rightImgSrc?: string;\r\n    slideDirection?: 'left' | 'right';\r\n    autoplay?: boolean;\r\n    duration?: number;\r\n    pauseOnHover?: boolean;\r\n    loop?: boolean;\r\n}\r\n\r\nexport const RevealPane = ({\r\n    className,\r\n    leftImgClassName,\r\n    rightImgClassName,\r\n    leftImgSrc = '',\r\n    rightImgSrc = '',\r\n    slideDirection = 'right',\r\n    autoplay = false,\r\n    duration = 5000,\r\n    pauseOnHover = true,\r\n    loop = true,\r\n}: RevealSliderProps) => {\r\n    const [sliderPosition, setSliderPosition] = useState(50);\r\n    const [isDragging, setIsDragging] = useState(false);\r\n    const [isHovered, setIsHovered] = useState(false);\r\n    const [direction, setDirection] = useState<'left' | 'right' | null>(null);\r\n    const [isAutoPlaying, setIsAutoPlaying] = useState(autoplay);\r\n    const [autoplayDirection, setAutoplayDirection] = useState<\r\n        'left' | 'right'\r\n    >('right');\r\n\r\n    const prevPositionRef = useRef(sliderPosition);\r\n    const autoplayIntervalRef = useRef<NodeJS.Timeout | null>(null);\r\n    const autoplayTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n    useEffect(() => {\r\n        if (sliderPosition > prevPositionRef.current && isDragging) {\r\n            setDirection('right');\r\n        } else if (sliderPosition < prevPositionRef.current && isDragging) {\r\n            setDirection('left');\r\n        } else if (!isDragging) {\r\n            setDirection(null);\r\n        }\r\n        prevPositionRef.current = sliderPosition;\r\n    }, [sliderPosition, isDragging]);\r\n\r\n    // Autoplay logic\r\n    useEffect(() => {\r\n        if (!autoplay || isDragging || (pauseOnHover && isHovered)) {\r\n            if (autoplayIntervalRef.current) {\r\n                clearInterval(autoplayIntervalRef.current);\r\n                autoplayIntervalRef.current = null;\r\n            }\r\n            if (autoplayTimeoutRef.current) {\r\n                clearTimeout(autoplayTimeoutRef.current);\r\n                autoplayTimeoutRef.current = null;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (isAutoPlaying) {\r\n            const startAutoplay = () => {\r\n                autoplayIntervalRef.current = setInterval(() => {\r\n                    setSliderPosition((prev) => {\r\n                        let newPosition;\r\n\r\n                        if (autoplayDirection === 'right') {\r\n                            newPosition = Math.min(prev + 1, 100);\r\n                            if (newPosition === 100 && loop) {\r\n                                // Switch direction after a pause\r\n                                autoplayTimeoutRef.current = setTimeout(() => {\r\n                                    setAutoplayDirection('left');\r\n                                }, 1000);\r\n                            }\r\n                        } else {\r\n                            newPosition = Math.max(prev - 1, 0);\r\n                            if (newPosition === 0 && loop) {\r\n                                // Switch direction after a pause\r\n                                autoplayTimeoutRef.current = setTimeout(() => {\r\n                                    setAutoplayDirection('right');\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n\r\n                        return newPosition;\r\n                    });\r\n                }, duration * 10); // multiply duration by 10 for smooth animation\r\n            };\r\n\r\n            startAutoplay();\r\n        }\r\n\r\n        return () => {\r\n            if (autoplayIntervalRef.current) {\r\n                clearInterval(autoplayIntervalRef.current);\r\n            }\r\n            if (autoplayTimeoutRef.current) {\r\n                clearTimeout(autoplayTimeoutRef.current);\r\n            }\r\n        };\r\n    }, [\r\n        autoplay,\r\n        isAutoPlaying,\r\n        isDragging,\r\n        isHovered,\r\n        pauseOnHover,\r\n        duration,\r\n        autoplayDirection,\r\n        loop,\r\n    ]);\r\n\r\n    // Initialize autoplay direction based on slideDirection prop\r\n    useEffect(() => {\r\n        setAutoplayDirection(slideDirection);\r\n    }, [slideDirection]);\r\n\r\n    // Helper function to get position from event (mouse or touch)\r\n    const getEventPosition = (e: any) => {\r\n        const clientX = e.touches ? e.touches[0].clientX : e.clientX;\r\n        const clientY = e.touches ? e.touches[0].clientY : e.clientY;\r\n        return { clientX, clientY };\r\n    };\r\n\r\n    // Helper function to update slider position\r\n    const updateSliderPosition = (clientX: number, rect: DOMRect) => {\r\n        const x = clientX - rect.left;\r\n        const percentage = (x / rect.width) * 100;\r\n        setSliderPosition(Math.min(Math.max(percentage, 0), 100));\r\n    };\r\n\r\n    const handleMove = (e: any) => {\r\n        if (!isDragging) return;\r\n\r\n        const { clientX } = getEventPosition(e);\r\n        const rect = e.currentTarget.getBoundingClientRect();\r\n        updateSliderPosition(clientX, rect);\r\n    };\r\n\r\n    const handleStart = () => {\r\n        setIsDragging(true);\r\n        setIsAutoPlaying(false); // Pause autoplay when user interacts\r\n    };\r\n\r\n    const handleEnd = () => {\r\n        setIsDragging(false);\r\n        // Resume autoplay after user interaction if it was initially enabled\r\n        if (autoplay) {\r\n            setTimeout(() => setIsAutoPlaying(true), 1000); // Resume after 1 second\r\n        }\r\n    };\r\n\r\n    const handleClick = (e: any) => {\r\n        // Prevent click handling if it was a drag operation\r\n        if (isDragging) return;\r\n\r\n        const { clientX } = getEventPosition(e);\r\n        const rect = e.currentTarget.getBoundingClientRect();\r\n        updateSliderPosition(clientX, rect);\r\n\r\n        // Pause and resume autoplay on click\r\n        if (autoplay) {\r\n            setIsAutoPlaying(false);\r\n            setTimeout(() => setIsAutoPlaying(true), 1000);\r\n        }\r\n    };\r\n\r\n    const handleMouseEnter = () => {\r\n        setIsHovered(true);\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n        setIsHovered(false);\r\n    };\r\n\r\n    useEffect(() => {\r\n        const handleGlobalEnd = () => setIsDragging(false);\r\n\r\n        const handleGlobalMove = (e: any) => {\r\n            if (!isDragging) return;\r\n\r\n            const { clientX, clientY } = getEventPosition(e);\r\n            const containers = document.querySelectorAll(\r\n                '[data-slider-container]'\r\n            );\r\n\r\n            containers.forEach((container) => {\r\n                const rect = container.getBoundingClientRect();\r\n                if (\r\n                    clientX >= rect.left &&\r\n                    clientX <= rect.right &&\r\n                    clientY >= rect.top &&\r\n                    clientY <= rect.bottom\r\n                ) {\r\n                    updateSliderPosition(clientX, rect);\r\n                }\r\n            });\r\n        };\r\n\r\n        // Add both mouse and touch event listeners\r\n        document.addEventListener('mouseup', handleGlobalEnd);\r\n        document.addEventListener('mousemove', handleGlobalMove);\r\n        document.addEventListener('touchend', handleGlobalEnd);\r\n        document.addEventListener('touchmove', handleGlobalMove, {\r\n            passive: false,\r\n        });\r\n\r\n        return () => {\r\n            document.removeEventListener('mouseup', handleGlobalEnd);\r\n            document.removeEventListener('mousemove', handleGlobalMove);\r\n            document.removeEventListener('touchend', handleGlobalEnd);\r\n            document.removeEventListener('touchmove', handleGlobalMove);\r\n        };\r\n    }, [isDragging]);\r\n\r\n    return (\r\n        <div\r\n            className={cn(\r\n                'relative aspect-auto h-72 w-84 cursor-pointer touch-none overflow-hidden rounded-lg bg-gray-800 select-none sm:aspect-[4/3] sm:min-h-96 sm:min-w-96',\r\n                className\r\n            )}\r\n            data-slider-container\r\n            // Mouse events\r\n            onMouseMove={handleMove}\r\n            onMouseDown={handleStart}\r\n            onMouseUp={handleEnd}\r\n            onClick={handleClick}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            // Touch events\r\n            onTouchStart={handleStart}\r\n            onTouchMove={handleMove}\r\n            onTouchEnd={handleEnd}\r\n        >\r\n            {/* right image */}\r\n            <div className={cn('absolute inset-0', rightImgClassName)}>\r\n                <Image\r\n                    src={rightImgSrc}\r\n                    alt=\"Right side image in Reveal Pane UI component for interactive image comparison\"\r\n                    width={500}\r\n                    height={500}\r\n                    className=\"h-full w-full object-cover\"\r\n                    draggable={false}\r\n                />\r\n            </div>\r\n\r\n            {/* left image*/}\r\n            <motion.div\r\n                className={cn('absolute inset-0', leftImgClassName)}\r\n                style={{\r\n                    clipPath: `inset(0 ${100 - sliderPosition}% 0 0)`,\r\n                }}\r\n                animate={{\r\n                    clipPath: `inset(0 ${100 - sliderPosition}% 0 0)`,\r\n                }}\r\n                transition={{\r\n                    type: 'tween',\r\n                    duration: isDragging ? 0 : isAutoPlaying ? 0.1 : 0.3,\r\n                    ease: 'easeOut',\r\n                }}\r\n            >\r\n                <Image\r\n                    src={leftImgSrc}\r\n                    alt=\"left side image in Reveal Pane core UI component for interactive image comparison\"\r\n                    className=\"h-full w-full object-cover\"\r\n                    width={500}\r\n                    height={500}\r\n                    draggable={false}\r\n                />\r\n            </motion.div>\r\n\r\n            {/* Slider Line */}\r\n            <motion.div\r\n                className=\"absolute top-0 bottom-0 z-10 w-0.5 bg-gradient-to-b from-transparent via-purple-400 to-transparent shadow-lg\"\r\n                style={{ left: `${sliderPosition}%` }}\r\n                animate={{ left: `${sliderPosition}%` }}\r\n                transition={{\r\n                    type: 'tween',\r\n                    duration: isDragging ? 0 : isAutoPlaying ? 0.1 : 0.3,\r\n                    ease: 'easeOut',\r\n                }}\r\n            >\r\n                {/* Slider Handle */}\r\n                <div className=\"absolute top-1/2 left-1/2 z-20 -translate-x-1/2 -translate-y-1/2 transform\">\r\n                    <motion.div\r\n                        className=\"z-20 flex h-8 w-8 cursor-grab items-center justify-center rounded-full border-1 border-purple-400 bg-purple-500 shadow-lg active:cursor-grabbing\"\r\n                        whileHover={{ scale: 1.1 }}\r\n                        whileTap={{ scale: 0.95 }}\r\n                        animate={{\r\n                            scale: isDragging\r\n                                ? 1.1\r\n                                : isAutoPlaying && !isHovered\r\n                                  ? [1, 1.1, 1]\r\n                                  : 1,\r\n                            boxShadow: isDragging\r\n                                ? '0 0 50px rgba(173,70,255)'\r\n                                : isAutoPlaying && !isHovered\r\n                                  ? '0 0 25px rgba(173,70,255,0.8)'\r\n                                  : '0 0 15px rgba(173,70,255,0.5)',\r\n                        }}\r\n                        transition={{\r\n                            duration: 2,\r\n                            repeat: isAutoPlaying && !isHovered ? Infinity : 0,\r\n                            ease: 'easeInOut',\r\n                        }}\r\n                    >\r\n                        <IconGripVertical className=\"h-4 w-4 text-white\" />\r\n                    </motion.div>\r\n                </div>\r\n\r\n                {/* Direction indicator sparkles */}\r\n                <motion.div\r\n                    className={cn(\r\n                        'absolute top-1/2 left-1/2 h-full w-20 -translate-y-1/2 transform bg-purple-300/10',\r\n                        (direction === 'left' ||\r\n                            (isAutoPlaying && autoplayDirection === 'left')) &&\r\n                            'translate-x-0 [mask-image:radial-gradient(400px_1000px_at_left,white,transparent_20%)]',\r\n                        (direction === 'right' ||\r\n                            (isAutoPlaying && autoplayDirection === 'right')) &&\r\n                            '-translate-x-full [mask-image:radial-gradient(400px_1000px_at_right,white,transparent_20%)]',\r\n                        !direction && !isAutoPlaying && 'hidden'\r\n                    )}\r\n                >\r\n                    <MemoizedSparkles\r\n                        background=\"transparent\"\r\n                        minSize={0.4}\r\n                        maxSize={1}\r\n                        particleDensity={300}\r\n                        particleColor=\"#ffffff\"\r\n                        speed={isAutoPlaying ? 0.5 : 1}\r\n                    />\r\n                </motion.div>\r\n            </motion.div>\r\n        </div>\r\n    );\r\n};\r\n\r\ntype ParticlesProps = {\r\n    className?: string;\r\n    background?: string;\r\n    particleSize?: number;\r\n    minSize?: number;\r\n    maxSize?: number;\r\n    speed?: number;\r\n    particleColor?: string;\r\n    particleDensity?: number;\r\n};\r\n\r\nexport const Sparkles = ({\r\n    background,\r\n    minSize,\r\n    maxSize,\r\n    speed,\r\n    particleColor,\r\n    particleDensity,\r\n}: ParticlesProps) => {\r\n    const [init, setInit] = useState(false);\r\n    const generatedId = useId();\r\n\r\n    useEffect(() => {\r\n        initParticlesEngine(async (engine) => {\r\n            await loadSlim(engine);\r\n        }).then(() => {\r\n            setInit(true);\r\n        });\r\n    }, []);\r\n\r\n    const fadeInControls = useAnimation();\r\n\r\n    const particlesLoaded = async (container?: Container): Promise<void> => {\r\n        container &&\r\n            fadeInControls.start({\r\n                opacity: 1,\r\n                transition: { duration: 1 },\r\n            });\r\n    };\r\n\r\n    const options: ISourceOptions = {\r\n        background: {\r\n            color: {\r\n                value: background || '#0d47a1',\r\n            },\r\n        },\r\n        fullScreen: {\r\n            enable: false,\r\n            zIndex: 1,\r\n        },\r\n\r\n        particles: {\r\n            color: {\r\n                value: particleColor || '#ffffff',\r\n            },\r\n            move: {\r\n                angle: {\r\n                    offset: 0,\r\n                    value: 90,\r\n                },\r\n                center: {\r\n                    x: 50,\r\n                    y: 50,\r\n                    mode: 'percent',\r\n                    radius: 0,\r\n                },\r\n                enable: true,\r\n                random: false,\r\n                size: false,\r\n                speed: {\r\n                    min: 0.1,\r\n                    max: 1,\r\n                },\r\n            },\r\n            number: {\r\n                density: {\r\n                    enable: true,\r\n                    width: 400,\r\n                    height: 400,\r\n                },\r\n                limit: {\r\n                    mode: 'delete',\r\n                    value: 0,\r\n                },\r\n                value: particleDensity || 120,\r\n            },\r\n            opacity: {\r\n                value: {\r\n                    min: 0.1,\r\n                    max: 1,\r\n                },\r\n                animation: {\r\n                    enable: true,\r\n                    speed: speed || 4,\r\n                    sync: false,\r\n                    mode: 'auto',\r\n                    startValue: 'random',\r\n                    destroy: 'none',\r\n                },\r\n            },\r\n            shape: {\r\n                close: true,\r\n                fill: true,\r\n                options: {},\r\n                type: 'circle',\r\n            },\r\n            size: {\r\n                value: {\r\n                    min: minSize || 1,\r\n                    max: maxSize || 3,\r\n                },\r\n            },\r\n        },\r\n    };\r\n\r\n    if (init) {\r\n        return (\r\n            <motion.div\r\n                animate={fadeInControls}\r\n                className={cn('h-full w-full opacity-0')}\r\n            >\r\n                <Particles\r\n                    className=\"h-full w-full\"\r\n                    id={generatedId}\r\n                    particlesLoaded={particlesLoaded}\r\n                    options={options}\r\n                />\r\n            </motion.div>\r\n        );\r\n    }\r\n\r\n    return <></>;\r\n};\r\n\r\nexport const MemoizedSparkles = React.memo(Sparkles);\r\n",
      "type": "registry:ui",
      "target": "components/ui/reveale-pane.tsx"
    }
  ]
}